function [q,g,h,r]=mybound(p,e,u,time)

% upper=double('2-2*x-x.^2');% y=1上边界条件函数 
% down =double('x.^2'); % y=0下边界条件函数 
% left =double('y.^2'); % x=0左边界条件函数 
% right=double('2-2*y-y.^2'); % x=1右边界条件函数 
% upper=upper'; % 转化为列向量 
% down =down'; 
% left =left'; 
% right=right'; 
% 
bl=[ 
1 1 1 1       % N 表示方程维数的指示行 
0 0 1 1       % M 表示Dirichlet边界条件的指示行，M=0为广义Neumann边界条件 
1 1 1 1       % q 表示q的字符串的长度，根据实际长度确定， 
10 10 1 1   % g 表示g的字符串的长度，如1表示字符串的长度为1 
48 48 1 1   % h 表示h的字符串的长度，这是针对M=1的列，本例子是三四列 
50 50 4 4   % r 表示r的字符串的长度，规则同上。 
45 45 48 48     % 本行以下是边界条件函数的字符串表达式，字符串的长度与上面 
50 50 48 48     % 规定的一致。注意，这些都是将表达式转化为ASCII码后的数 
42 42 49 49     % 例如x的ASCII码是120，ASCII码的0表示null（空） 
120 121 120 121      % 需要注意的还有，M=0的列，字符表达式从g的下一行开始， 
45 45 46 46            % 即从第5行开始。M=1的列，从r的下一行开始，即7,8两行是 
120 121 94 94        % 表示q，g的字符串的长度，此时认为q，g均为0， 0的ASCII 
46 46 50 50            % 码是48，因此7,8两行均为48。在往下，按照h，r的长度排列。 
94 94 0 0                % 由此造成的行数不匹配，可以由任意ASCII码补齐，一般以0 
50 50 0 0                % （表示null，空）表示，不容易引起歧义。 
]; 

if any(size(u)) 
[q,g,h,r]=pdeexpd(p,e,u,time,bl); 
else 
[q,g,h,r]=pdeexpd(p,e,time,bl); 
end